<?php
/**
 * ShipmentApi
 * PHP version 5
 *
 * @category Class
 * @package  WebnessStudio/MPL/Model
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * MPL API
 *
 * <div style='width: 100%;margin: 0px auto;'>      <div style='float: left; width:47%'>          <h1>MPL API</h1>          <h2> - címiratok nyomtatása, riportok lekérése, fixpontok lekérdezése </h2>          <div>&nbsp;</div>          <p>A végpontok működését leíró dokumentációt lentebb találja.</p>          <p>A fejlesztéshez szükséges további információkat, így az integrációs javaslatot, technikai leírást (token kérés), példa json-öket, stb., a fenti Dokumentáció menüre kattintva érheti el.</p>          <p>A lentebbi dokumentációban a</p>          <ul>              <li>csak belföldi alapszolgáltatáshoz használható elemeket a leírás elején szereplő ►DOM◄,</li>              <li>csak nemzetközi vonatkozásban használható elemeket a leírás elején szereplő ►INT◄</li>          </ul>          <p>szöveg jelzi.</p>          <p>Ahol nem szerepel semmilyen jelölés, azok az elemek mindkét vonatkozásban használhatók.</p>      </div>      <div style='float:right; width:47%'>          <h1>MPL API</h1>          <h2> - query of fixed points, printing of address labels, request for reports </h2>          <div>&nbsp;</div>          <p>Specification describing the operation of endpoints can be found below.</p>          <p>Any further information necessary for the development, such as the integration suggestion, technical description (token request), example JSONs, etc., are available by clicking on the Documentation menu above.</p>          <p>In the specification below,</p>          <ul>              <li>the elements that may be used only for domestic basic service are indicated by the lettering ►DOM◄,</li>              <li>the elements that may be used only in international regard are indicated by the lettering ►INT◄</li>          </ul>          <p>at the beginning of the description.</p>          <p>Where no indication is provided, those elements can be used in both cases.</p>      </div>  </div>  <div id=\"mplapi_descriptionContainer_bottom\"></div><div style='clear: both;'>    ### Az API a következő URL-eken érhető el: / This API can be accessed at the following URLs: ###  <div><table><tr><td><b>Környezet / Environment</b></td><td><b>API URL</b></td><td><b>OAuth2 Token URL</b></td></tr><tr><td>Sandbox</td><td>https://sandbox.api.posta.hu/v2/mplapi</td><td>https://sandbox.api.posta.hu/oauth2/token</td></tr><tr><td>Production</td><td>https://core.api.posta.hu/v2/mplapi</td><td>https://core.api.posta.hu/oauth2/token</td></tr></table>  Az API ezen az oldalon a Sandbox környezetben tesztelhető. / You can test the API on this page in the Sandbox environment.
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace WebnessStudio/MPL/Model\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use WebnessStudio/MPL/Model\ApiException;
use WebnessStudio/MPL/Model\Configuration;
use WebnessStudio/MPL/Model\HeaderSelector;
use WebnessStudio/MPL/Model\ObjectSerializer;

/**
 * ShipmentApi Class Doc Comment
 *
 * @category Class
 * @package  WebnessStudio/MPL/Model
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ShipmentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation shipmentsClosePost
     *
     * Jegyzékzárási kérés. Egyazon beszállítással feladni kívánt csomagok halmazának zárása, továbbá a zárásról egy szállítólevél igénylése. A lezárandó szállítmányokban alkalmazott feladói adatok (megállapodás, feladói név, feladói cím, bankszámla), illetve az irány (inverz?) függvényében a válaszunk akár több objektumot is tartalmazhat.   /   Request for closing the list. Closing a set of mail items to be dispatched with the same transport, and requesting a delivery note on the closing of the list. Depending on the data (agreement, sender’s name, sender’s address, bank account) and direction (inverse?) used in the shipments to be closed, our response may contain several objects.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCloseRequest $body body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\ShipmentCloseResult[]
     */
    public function shipmentsClosePost($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        list($response) = $this->shipmentsClosePostWithHttpInfo($x_request_id, $x_accounting_code, $body, $x_correlation_id);
        return $response;
    }

    /**
     * Operation shipmentsClosePostWithHttpInfo
     *
     * Jegyzékzárási kérés. Egyazon beszállítással feladni kívánt csomagok halmazának zárása, továbbá a zárásról egy szállítólevél igénylése. A lezárandó szállítmányokban alkalmazott feladói adatok (megállapodás, feladói név, feladói cím, bankszámla), illetve az irány (inverz?) függvényében a válaszunk akár több objektumot is tartalmazhat.   /   Request for closing the list. Closing a set of mail items to be dispatched with the same transport, and requesting a delivery note on the closing of the list. Depending on the data (agreement, sender’s name, sender’s address, bank account) and direction (inverse?) used in the shipments to be closed, our response may contain several objects.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCloseRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\ShipmentCloseResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsClosePostWithHttpInfo($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentCloseResult[]';
        $request = $this->shipmentsClosePostRequest($x_request_id, $x_accounting_code, $body, $x_correlation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ShipmentCloseResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsClosePostAsync
     *
     * Jegyzékzárási kérés. Egyazon beszállítással feladni kívánt csomagok halmazának zárása, továbbá a zárásról egy szállítólevél igénylése. A lezárandó szállítmányokban alkalmazott feladói adatok (megállapodás, feladói név, feladói cím, bankszámla), illetve az irány (inverz?) függvényében a válaszunk akár több objektumot is tartalmazhat.   /   Request for closing the list. Closing a set of mail items to be dispatched with the same transport, and requesting a delivery note on the closing of the list. Depending on the data (agreement, sender’s name, sender’s address, bank account) and direction (inverse?) used in the shipments to be closed, our response may contain several objects.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCloseRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsClosePostAsync($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        return $this->shipmentsClosePostAsyncWithHttpInfo($x_request_id, $x_accounting_code, $body, $x_correlation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsClosePostAsyncWithHttpInfo
     *
     * Jegyzékzárási kérés. Egyazon beszállítással feladni kívánt csomagok halmazának zárása, továbbá a zárásról egy szállítólevél igénylése. A lezárandó szállítmányokban alkalmazott feladói adatok (megállapodás, feladói név, feladói cím, bankszámla), illetve az irány (inverz?) függvényében a válaszunk akár több objektumot is tartalmazhat.   /   Request for closing the list. Closing a set of mail items to be dispatched with the same transport, and requesting a delivery note on the closing of the list. Depending on the data (agreement, sender’s name, sender’s address, bank account) and direction (inverse?) used in the shipments to be closed, our response may contain several objects.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCloseRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsClosePostAsyncWithHttpInfo($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentCloseResult[]';
        $request = $this->shipmentsClosePostRequest($x_request_id, $x_accounting_code, $body, $x_correlation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsClosePost'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCloseRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsClosePostRequest($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsClosePost'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsClosePost'
            );
        }

        $resourcePath = '/shipments/close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shipmentsGet
     *
     * Visszaadja, hogy az adott ügyfél milyen csomagjairól mit tud opcionálisan csak a megadott időpontok között és megadott darabszámig.   /   Indicates what is known about what parcels of the given customer, optionally, only between the specified times and up to the specified number of parcels.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  \DateTime $from_date Mettől szűrjön a lekérdezés.   /   Filter the query from. (optional)
     * @param  \DateTime $to_date Meddig szűrjön a lekérdezés.   /   Filter the query to. (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (optional)
     * @param  string $tag Küldemény cimkéje   /   Mail item label (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\ShipmentQueryResult[]
     */
    public function shipmentsGet($x_request_id, $x_accounting_code, $x_correlation_id = null, $from_date = null, $to_date = null, $tracking_numbers = null, $tag = null)
    {
        list($response) = $this->shipmentsGetWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id, $from_date, $to_date, $tracking_numbers, $tag);
        return $response;
    }

    /**
     * Operation shipmentsGetWithHttpInfo
     *
     * Visszaadja, hogy az adott ügyfél milyen csomagjairól mit tud opcionálisan csak a megadott időpontok között és megadott darabszámig.   /   Indicates what is known about what parcels of the given customer, optionally, only between the specified times and up to the specified number of parcels.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  \DateTime $from_date Mettől szűrjön a lekérdezés.   /   Filter the query from. (optional)
     * @param  \DateTime $to_date Meddig szűrjön a lekérdezés.   /   Filter the query to. (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (optional)
     * @param  string $tag Küldemény cimkéje   /   Mail item label (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\ShipmentQueryResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsGetWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id = null, $from_date = null, $to_date = null, $tracking_numbers = null, $tag = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentQueryResult[]';
        $request = $this->shipmentsGetRequest($x_request_id, $x_accounting_code, $x_correlation_id, $from_date, $to_date, $tracking_numbers, $tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ShipmentQueryResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsGetAsync
     *
     * Visszaadja, hogy az adott ügyfél milyen csomagjairól mit tud opcionálisan csak a megadott időpontok között és megadott darabszámig.   /   Indicates what is known about what parcels of the given customer, optionally, only between the specified times and up to the specified number of parcels.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  \DateTime $from_date Mettől szűrjön a lekérdezés.   /   Filter the query from. (optional)
     * @param  \DateTime $to_date Meddig szűrjön a lekérdezés.   /   Filter the query to. (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (optional)
     * @param  string $tag Küldemény cimkéje   /   Mail item label (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsGetAsync($x_request_id, $x_accounting_code, $x_correlation_id = null, $from_date = null, $to_date = null, $tracking_numbers = null, $tag = null)
    {
        return $this->shipmentsGetAsyncWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id, $from_date, $to_date, $tracking_numbers, $tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsGetAsyncWithHttpInfo
     *
     * Visszaadja, hogy az adott ügyfél milyen csomagjairól mit tud opcionálisan csak a megadott időpontok között és megadott darabszámig.   /   Indicates what is known about what parcels of the given customer, optionally, only between the specified times and up to the specified number of parcels.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  \DateTime $from_date Mettől szűrjön a lekérdezés.   /   Filter the query from. (optional)
     * @param  \DateTime $to_date Meddig szűrjön a lekérdezés.   /   Filter the query to. (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (optional)
     * @param  string $tag Küldemény cimkéje   /   Mail item label (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsGetAsyncWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id = null, $from_date = null, $to_date = null, $tracking_numbers = null, $tag = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentQueryResult[]';
        $request = $this->shipmentsGetRequest($x_request_id, $x_accounting_code, $x_correlation_id, $from_date, $to_date, $tracking_numbers, $tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsGet'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  \DateTime $from_date Mettől szűrjön a lekérdezés.   /   Filter the query from. (optional)
     * @param  \DateTime $to_date Meddig szűrjön a lekérdezés.   /   Filter the query to. (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (optional)
     * @param  string $tag Küldemény cimkéje   /   Mail item label (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsGetRequest($x_request_id, $x_accounting_code, $x_correlation_id = null, $from_date = null, $to_date = null, $tracking_numbers = null, $tag = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsGet'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsGet'
            );
        }

        $resourcePath = '/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from_date !== null) {
            $queryParams['fromDate'] = ObjectSerializer::toQueryValue($from_date, 'date');
        }
        // query params
        if ($to_date !== null) {
            $queryParams['toDate'] = ObjectSerializer::toQueryValue($to_date, 'date');
        }
        // query params
        if (is_array($tracking_numbers)) {
            $tracking_numbers = ObjectSerializer::serializeCollection($tracking_numbers, 'multi', true);
        }
        if ($tracking_numbers !== null) {
            $queryParams['trackingNumbers'] = ObjectSerializer::toQueryValue($tracking_numbers, null);
        }
        // query params
        if ($tag !== null) {
            $queryParams['tag'] = ObjectSerializer::toQueryValue($tag, null);
        }
        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shipmentsLabelGet
     *
     * Csomag(ok) címiratának lekérése.    /   Query address label of parcel(s)
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (tracking numbers) (optional)
     * @param  string $label_type A címirat formátuma   /   Address label format (optional)
     * @param  string $label_format A generált címirat formátuma (optional, default to PDF)
     * @param  string $order_by A címiratok sorrendje a PDF fájlon belül.   /   Order of the address labels in the PDF file. (optional)
     * @param  bool $single_file Az eredmény címiratok egyetlen PDF fájlban vagy külön PDF fájlokban készüljenek   /   Create address label results in a single PDF or in separate PDFs (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\LabelQueryResult[]
     */
    public function shipmentsLabelGet($x_request_id, $x_accounting_code, $x_correlation_id = null, $tracking_numbers = null, $label_type = null, $label_format = 'PDF', $order_by = null, $single_file = null)
    {
        list($response) = $this->shipmentsLabelGetWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id, $tracking_numbers, $label_type, $label_format, $order_by, $single_file);
        return $response;
    }

    /**
     * Operation shipmentsLabelGetWithHttpInfo
     *
     * Csomag(ok) címiratának lekérése.    /   Query address label of parcel(s)
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (tracking numbers) (optional)
     * @param  string $label_type A címirat formátuma   /   Address label format (optional)
     * @param  string $label_format A generált címirat formátuma (optional, default to PDF)
     * @param  string $order_by A címiratok sorrendje a PDF fájlon belül.   /   Order of the address labels in the PDF file. (optional)
     * @param  bool $single_file Az eredmény címiratok egyetlen PDF fájlban vagy külön PDF fájlokban készüljenek   /   Create address label results in a single PDF or in separate PDFs (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\LabelQueryResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsLabelGetWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id = null, $tracking_numbers = null, $label_type = null, $label_format = 'PDF', $order_by = null, $single_file = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\LabelQueryResult[]';
        $request = $this->shipmentsLabelGetRequest($x_request_id, $x_accounting_code, $x_correlation_id, $tracking_numbers, $label_type, $label_format, $order_by, $single_file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\LabelQueryResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsLabelGetAsync
     *
     * Csomag(ok) címiratának lekérése.    /   Query address label of parcel(s)
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (tracking numbers) (optional)
     * @param  string $label_type A címirat formátuma   /   Address label format (optional)
     * @param  string $label_format A generált címirat formátuma (optional, default to PDF)
     * @param  string $order_by A címiratok sorrendje a PDF fájlon belül.   /   Order of the address labels in the PDF file. (optional)
     * @param  bool $single_file Az eredmény címiratok egyetlen PDF fájlban vagy külön PDF fájlokban készüljenek   /   Create address label results in a single PDF or in separate PDFs (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsLabelGetAsync($x_request_id, $x_accounting_code, $x_correlation_id = null, $tracking_numbers = null, $label_type = null, $label_format = 'PDF', $order_by = null, $single_file = null)
    {
        return $this->shipmentsLabelGetAsyncWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id, $tracking_numbers, $label_type, $label_format, $order_by, $single_file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsLabelGetAsyncWithHttpInfo
     *
     * Csomag(ok) címiratának lekérése.    /   Query address label of parcel(s)
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (tracking numbers) (optional)
     * @param  string $label_type A címirat formátuma   /   Address label format (optional)
     * @param  string $label_format A generált címirat formátuma (optional, default to PDF)
     * @param  string $order_by A címiratok sorrendje a PDF fájlon belül.   /   Order of the address labels in the PDF file. (optional)
     * @param  bool $single_file Az eredmény címiratok egyetlen PDF fájlban vagy külön PDF fájlokban készüljenek   /   Create address label results in a single PDF or in separate PDFs (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsLabelGetAsyncWithHttpInfo($x_request_id, $x_accounting_code, $x_correlation_id = null, $tracking_numbers = null, $label_type = null, $label_format = 'PDF', $order_by = null, $single_file = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\LabelQueryResult[]';
        $request = $this->shipmentsLabelGetRequest($x_request_id, $x_accounting_code, $x_correlation_id, $tracking_numbers, $label_type, $label_format, $order_by, $single_file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsLabelGet'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     * @param  string[] $tracking_numbers A kiválasztott postai azonosítók (ragszámok)   /   Selected postal IDs (tracking numbers) (optional)
     * @param  string $label_type A címirat formátuma   /   Address label format (optional)
     * @param  string $label_format A generált címirat formátuma (optional, default to PDF)
     * @param  string $order_by A címiratok sorrendje a PDF fájlon belül.   /   Order of the address labels in the PDF file. (optional)
     * @param  bool $single_file Az eredmény címiratok egyetlen PDF fájlban vagy külön PDF fájlokban készüljenek   /   Create address label results in a single PDF or in separate PDFs (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsLabelGetRequest($x_request_id, $x_accounting_code, $x_correlation_id = null, $tracking_numbers = null, $label_type = null, $label_format = 'PDF', $order_by = null, $single_file = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsLabelGet'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsLabelGet'
            );
        }

        $resourcePath = '/shipments/label';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tracking_numbers)) {
            $tracking_numbers = ObjectSerializer::serializeCollection($tracking_numbers, 'multi', true);
        }
        if ($tracking_numbers !== null) {
            $queryParams['trackingNumbers'] = ObjectSerializer::toQueryValue($tracking_numbers, null);
        }
        // query params
        if ($label_type !== null) {
            $queryParams['labelType'] = ObjectSerializer::toQueryValue($label_type, null);
        }
        // query params
        if ($label_format !== null) {
            $queryParams['labelFormat'] = ObjectSerializer::toQueryValue($label_format, null);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by, null);
        }
        // query params
        if ($single_file !== null) {
            $queryParams['singleFile'] = ObjectSerializer::toQueryValue($single_file, null);
        }
        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shipmentsPost
     *
     * Csomagadat(ok) beküldése.   /   Submission of parcel data.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCreateRequest[] $body Az új szállítmányok értékei JSON formátumban. (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\ShipmentCreateResult[]
     */
    public function shipmentsPost($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        list($response) = $this->shipmentsPostWithHttpInfo($x_request_id, $x_accounting_code, $body, $x_correlation_id);
        return $response;
    }

    /**
     * Operation shipmentsPostWithHttpInfo
     *
     * Csomagadat(ok) beküldése.   /   Submission of parcel data.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCreateRequest[] $body Az új szállítmányok értékei JSON formátumban. (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\ShipmentCreateResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsPostWithHttpInfo($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentCreateResult[]';
        $request = $this->shipmentsPostRequest($x_request_id, $x_accounting_code, $body, $x_correlation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ShipmentCreateResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsPostAsync
     *
     * Csomagadat(ok) beküldése.   /   Submission of parcel data.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCreateRequest[] $body Az új szállítmányok értékei JSON formátumban. (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsPostAsync($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        return $this->shipmentsPostAsyncWithHttpInfo($x_request_id, $x_accounting_code, $body, $x_correlation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsPostAsyncWithHttpInfo
     *
     * Csomagadat(ok) beküldése.   /   Submission of parcel data.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCreateRequest[] $body Az új szállítmányok értékei JSON formátumban. (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsPostAsyncWithHttpInfo($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentCreateResult[]';
        $request = $this->shipmentsPostRequest($x_request_id, $x_accounting_code, $body, $x_correlation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsPost'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentCreateRequest[] $body Az új szállítmányok értékei JSON formátumban. (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsPostRequest($x_request_id, $x_accounting_code, $body = null, $x_correlation_id = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsPost'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsPost'
            );
        }

        $resourcePath = '/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shipmentsTrackingNumberDelete
     *
     * Ragszám szerinti tétel törlése.   /   Deletion of item by tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\ShipmentDeleteResult
     */
    public function shipmentsTrackingNumberDelete($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        list($response) = $this->shipmentsTrackingNumberDeleteWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id);
        return $response;
    }

    /**
     * Operation shipmentsTrackingNumberDeleteWithHttpInfo
     *
     * Ragszám szerinti tétel törlése.   /   Deletion of item by tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\ShipmentDeleteResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsTrackingNumberDeleteWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentDeleteResult';
        $request = $this->shipmentsTrackingNumberDeleteRequest($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ShipmentDeleteResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsTrackingNumberDeleteAsync
     *
     * Ragszám szerinti tétel törlése.   /   Deletion of item by tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsTrackingNumberDeleteAsync($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        return $this->shipmentsTrackingNumberDeleteAsyncWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsTrackingNumberDeleteAsyncWithHttpInfo
     *
     * Ragszám szerinti tétel törlése.   /   Deletion of item by tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsTrackingNumberDeleteAsyncWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentDeleteResult';
        $request = $this->shipmentsTrackingNumberDeleteRequest($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsTrackingNumberDelete'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsTrackingNumberDeleteRequest($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsTrackingNumberDelete'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsTrackingNumberDelete'
            );
        }
        // verify the required parameter 'tracking_number' is set
        if ($tracking_number === null || (is_array($tracking_number) && count($tracking_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tracking_number when calling shipmentsTrackingNumberDelete'
            );
        }

        $resourcePath = '/shipments/{trackingNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }

        // path params
        if ($tracking_number !== null) {
            $resourcePath = str_replace(
                '{' . 'trackingNumber' . '}',
                ObjectSerializer::toPathValue($tracking_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shipmentsTrackingNumberGet
     *
     * Ragszám szerinti feladandó tétel lekérdezése.   /   Querying of item to be sent through tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\ShipmentQueryResult
     */
    public function shipmentsTrackingNumberGet($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        list($response) = $this->shipmentsTrackingNumberGetWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id);
        return $response;
    }

    /**
     * Operation shipmentsTrackingNumberGetWithHttpInfo
     *
     * Ragszám szerinti feladandó tétel lekérdezése.   /   Querying of item to be sent through tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\ShipmentQueryResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsTrackingNumberGetWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentQueryResult';
        $request = $this->shipmentsTrackingNumberGetRequest($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ShipmentQueryResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsTrackingNumberGetAsync
     *
     * Ragszám szerinti feladandó tétel lekérdezése.   /   Querying of item to be sent through tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsTrackingNumberGetAsync($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        return $this->shipmentsTrackingNumberGetAsyncWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsTrackingNumberGetAsyncWithHttpInfo
     *
     * Ragszám szerinti feladandó tétel lekérdezése.   /   Querying of item to be sent through tracking number.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsTrackingNumberGetAsyncWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentQueryResult';
        $request = $this->shipmentsTrackingNumberGetRequest($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsTrackingNumberGet'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number Szállítmány azonosító   /   Postal ID (required)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsTrackingNumberGetRequest($x_request_id, $x_accounting_code, $tracking_number, $x_correlation_id = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsTrackingNumberGet'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsTrackingNumberGet'
            );
        }
        // verify the required parameter 'tracking_number' is set
        if ($tracking_number === null || (is_array($tracking_number) && count($tracking_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tracking_number when calling shipmentsTrackingNumberGet'
            );
        }

        $resourcePath = '/shipments/{trackingNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }

        // path params
        if ($tracking_number !== null) {
            $resourcePath = str_replace(
                '{' . 'trackingNumber' . '}',
                ObjectSerializer::toPathValue($tracking_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shipmentsTrackingNumberItemPost
     *
     * Új csomag(ok) felvétele meglevő nem együtt kézbesítendő szállítmányba.   /   Adding of new parcel(s) to an existing separately deliverable consignment.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number tracking_number (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentItemAddRequest $body body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \WebnessStudio/MPL/Model\Model\ShipmentItemAddResult[]
     */
    public function shipmentsTrackingNumberItemPost($x_request_id, $x_accounting_code, $tracking_number, $body = null, $x_correlation_id = null)
    {
        list($response) = $this->shipmentsTrackingNumberItemPostWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $body, $x_correlation_id);
        return $response;
    }

    /**
     * Operation shipmentsTrackingNumberItemPostWithHttpInfo
     *
     * Új csomag(ok) felvétele meglevő nem együtt kézbesítendő szállítmányba.   /   Adding of new parcel(s) to an existing separately deliverable consignment.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentItemAddRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \WebnessStudio/MPL/Model\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \WebnessStudio/MPL/Model\Model\ShipmentItemAddResult[], HTTP status code, HTTP response headers (array of strings)
     */
    public function shipmentsTrackingNumberItemPostWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $body = null, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentItemAddResult[]';
        $request = $this->shipmentsTrackingNumberItemPostRequest($x_request_id, $x_accounting_code, $tracking_number, $body, $x_correlation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ShipmentItemAddResult[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\WebnessStudio/MPL/Model\Model\ApiGatewayErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation shipmentsTrackingNumberItemPostAsync
     *
     * Új csomag(ok) felvétele meglevő nem együtt kézbesítendő szállítmányba.   /   Adding of new parcel(s) to an existing separately deliverable consignment.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentItemAddRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsTrackingNumberItemPostAsync($x_request_id, $x_accounting_code, $tracking_number, $body = null, $x_correlation_id = null)
    {
        return $this->shipmentsTrackingNumberItemPostAsyncWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $body, $x_correlation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shipmentsTrackingNumberItemPostAsyncWithHttpInfo
     *
     * Új csomag(ok) felvétele meglevő nem együtt kézbesítendő szállítmányba.   /   Adding of new parcel(s) to an existing separately deliverable consignment.
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentItemAddRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shipmentsTrackingNumberItemPostAsyncWithHttpInfo($x_request_id, $x_accounting_code, $tracking_number, $body = null, $x_correlation_id = null)
    {
        $returnType = '\WebnessStudio/MPL/Model\Model\ShipmentItemAddResult[]';
        $request = $this->shipmentsTrackingNumberItemPostRequest($x_request_id, $x_accounting_code, $tracking_number, $body, $x_correlation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'shipmentsTrackingNumberItemPost'
     *
     * @param  string $x_request_id A kérés egyedi azonosítója (UUID formátumban)   /   The unique request ID (UUID format) (required)
     * @param  string $x_accounting_code Vevőkód   /   The accounting code (required)
     * @param  string $tracking_number (required)
     * @param  \WebnessStudio/MPL/Model\Model\ShipmentItemAddRequest $body (optional)
     * @param  string $x_correlation_id Korrelációs azonosító (UUID formátumban)   /   The request correlation ID (UUID format) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shipmentsTrackingNumberItemPostRequest($x_request_id, $x_accounting_code, $tracking_number, $body = null, $x_correlation_id = null)
    {
        // verify the required parameter 'x_request_id' is set
        if ($x_request_id === null || (is_array($x_request_id) && count($x_request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_request_id when calling shipmentsTrackingNumberItemPost'
            );
        }
        // verify the required parameter 'x_accounting_code' is set
        if ($x_accounting_code === null || (is_array($x_accounting_code) && count($x_accounting_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $x_accounting_code when calling shipmentsTrackingNumberItemPost'
            );
        }
        // verify the required parameter 'tracking_number' is set
        if ($tracking_number === null || (is_array($tracking_number) && count($tracking_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tracking_number when calling shipmentsTrackingNumberItemPost'
            );
        }

        $resourcePath = '/shipments/{trackingNumber}/item';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-Id'] = ObjectSerializer::toHeaderValue($x_request_id);
        }
        // header params
        if ($x_correlation_id !== null) {
            $headerParams['X-Correlation-Id'] = ObjectSerializer::toHeaderValue($x_correlation_id);
        }
        // header params
        if ($x_accounting_code !== null) {
            $headerParams['X-Accounting-Code'] = ObjectSerializer::toHeaderValue($x_accounting_code);
        }

        // path params
        if ($tracking_number !== null) {
            $resourcePath = str_replace(
                '{' . 'trackingNumber' . '}',
                ObjectSerializer::toPathValue($tracking_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
