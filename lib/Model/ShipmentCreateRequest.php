<?php
/**
 * ShipmentCreateRequest
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  WebnessStudio\MPL
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MPL API
 *
 * <div style='width: 100%;margin: 0px auto;'>      <div style='float: left; width:47%'>          <h1>MPL API</h1>          <h2> - címiratok nyomtatása, riportok lekérése, fixpontok lekérdezése </h2>          <div>&nbsp;</div>          <p>A végpontok működését leíró dokumentációt lentebb találja.</p>          <p>A fejlesztéshez szükséges további információkat, így az integrációs javaslatot, technikai leírást (token kérés), példa json-öket, stb., a fenti Dokumentáció menüre kattintva érheti el.</p>          <p>A lentebbi dokumentációban a</p>          <ul>              <li>csak belföldi alapszolgáltatáshoz használható elemeket a leírás elején szereplő ►DOM◄,</li>              <li>csak nemzetközi vonatkozásban használható elemeket a leírás elején szereplő ►INT◄</li>          </ul>          <p>szöveg jelzi.</p>          <p>Ahol nem szerepel semmilyen jelölés, azok az elemek mindkét vonatkozásban használhatók.</p>      </div>      <div style='float:right; width:47%'>          <h1>MPL API</h1>          <h2> - query of fixed points, printing of address labels, request for reports </h2>          <div>&nbsp;</div>          <p>Specification describing the operation of endpoints can be found below.</p>          <p>Any further information necessary for the development, such as the integration suggestion, technical description (token request), example JSONs, etc., are available by clicking on the Documentation menu above.</p>          <p>In the specification below,</p>          <ul>              <li>the elements that may be used only for domestic basic service are indicated by the lettering ►DOM◄,</li>              <li>the elements that may be used only in international regard are indicated by the lettering ►INT◄</li>          </ul>          <p>at the beginning of the description.</p>          <p>Where no indication is provided, those elements can be used in both cases.</p>      </div>  </div>  <div id=\"mplapi_descriptionContainer_bottom\"></div><div style='clear: both;'>    ### Az API a következő URL-eken érhető el: / This API can be accessed at the following URLs: ###  <div><table><tr><td><b>Környezet / Environment</b></td><td><b>API URL</b></td><td><b>OAuth2 Token URL</b></td></tr><tr><td>Sandbox</td><td>https://sandbox.api.posta.hu/v2/mplapi</td><td>https://sandbox.api.posta.hu/oauth2/token</td></tr><tr><td>Production</td><td>https://core.api.posta.hu/v2/mplapi</td><td>https://core.api.posta.hu/oauth2/token</td></tr></table>  Az API ezen az oldalon a Sandbox környezetben tesztelhető. / You can test the API on this page in the Sandbox environment.
 *
 * The version of the OpenAPI document: v2
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace WebnessStudio\MPL\Model;

use \ArrayAccess;
use \WebnessStudio\MPL\ObjectSerializer;

/**
 * ShipmentCreateRequest Class Doc Comment
 *
 * @category Class
 * @description Szállítmány létrehozásához szükséges adatok   /   Data required to create a consignment
 * @package  WebnessStudio\MPL
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ShipmentCreateRequest implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ShipmentCreateRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'developer' => 'string',
        'sender' => '\WebnessStudio\MPL\Model\Sender',
        'non_utf8_sender' => '\WebnessStudio\MPL\Model\NonUTF8Sender',
        'shipment_date' => '\DateTime',
        'order_id' => 'string',
        'webshop_id' => 'string',
        'label_type' => 'string',
        'label_format' => 'string',
        'tag' => 'string',
        'group_together' => 'bool',
        'delivery_time' => 'string',
        'delivery_date' => '\DateTime',
        'item' => '\WebnessStudio\MPL\Model\Item[]',
        'recipient' => '\WebnessStudio\MPL\Model\Recipient',
        'non_utf8_recipient' => '\WebnessStudio\MPL\Model\NonUTF8Recipient',
        'payment_mode' => 'string',
        'package_retention' => 'int',
        'print_recipient_data' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'developer' => null,
        'sender' => null,
        'non_utf8_sender' => null,
        'shipment_date' => 'date',
        'order_id' => null,
        'webshop_id' => null,
        'label_type' => null,
        'label_format' => null,
        'tag' => null,
        'group_together' => null,
        'delivery_time' => null,
        'delivery_date' => 'date',
        'item' => null,
        'recipient' => null,
        'non_utf8_recipient' => null,
        'payment_mode' => null,
        'package_retention' => 'int32',
        'print_recipient_data' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'developer' => false,
        'sender' => false,
        'non_utf8_sender' => false,
        'shipment_date' => true,
        'order_id' => true,
        'webshop_id' => false,
        'label_type' => true,
        'label_format' => true,
        'tag' => true,
        'group_together' => true,
        'delivery_time' => true,
        'delivery_date' => true,
        'item' => true,
        'recipient' => false,
        'non_utf8_recipient' => false,
        'payment_mode' => true,
        'package_retention' => true,
        'print_recipient_data' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'developer' => 'developer',
        'sender' => 'sender',
        'non_utf8_sender' => 'nonUTF8Sender',
        'shipment_date' => 'shipmentDate',
        'order_id' => 'orderId',
        'webshop_id' => 'webshopId',
        'label_type' => 'labelType',
        'label_format' => 'labelFormat',
        'tag' => 'tag',
        'group_together' => 'groupTogether',
        'delivery_time' => 'deliveryTime',
        'delivery_date' => 'deliveryDate',
        'item' => 'item',
        'recipient' => 'recipient',
        'non_utf8_recipient' => 'nonUTF8Recipient',
        'payment_mode' => 'paymentMode',
        'package_retention' => 'packageRetention',
        'print_recipient_data' => 'printRecipientData'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'developer' => 'setDeveloper',
        'sender' => 'setSender',
        'non_utf8_sender' => 'setNonUtf8Sender',
        'shipment_date' => 'setShipmentDate',
        'order_id' => 'setOrderId',
        'webshop_id' => 'setWebshopId',
        'label_type' => 'setLabelType',
        'label_format' => 'setLabelFormat',
        'tag' => 'setTag',
        'group_together' => 'setGroupTogether',
        'delivery_time' => 'setDeliveryTime',
        'delivery_date' => 'setDeliveryDate',
        'item' => 'setItem',
        'recipient' => 'setRecipient',
        'non_utf8_recipient' => 'setNonUtf8Recipient',
        'payment_mode' => 'setPaymentMode',
        'package_retention' => 'setPackageRetention',
        'print_recipient_data' => 'setPrintRecipientData'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'developer' => 'getDeveloper',
        'sender' => 'getSender',
        'non_utf8_sender' => 'getNonUtf8Sender',
        'shipment_date' => 'getShipmentDate',
        'order_id' => 'getOrderId',
        'webshop_id' => 'getWebshopId',
        'label_type' => 'getLabelType',
        'label_format' => 'getLabelFormat',
        'tag' => 'getTag',
        'group_together' => 'getGroupTogether',
        'delivery_time' => 'getDeliveryTime',
        'delivery_date' => 'getDeliveryDate',
        'item' => 'getItem',
        'recipient' => 'getRecipient',
        'non_utf8_recipient' => 'getNonUtf8Recipient',
        'payment_mode' => 'getPaymentMode',
        'package_retention' => 'getPackageRetention',
        'print_recipient_data' => 'getPrintRecipientData'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const LABEL_TYPE_A4 = 'A4';
    public const LABEL_TYPE_A5 = 'A5';
    public const LABEL_TYPE_A5IN_A4 = 'A5inA4';
    public const LABEL_TYPE_A5_E = 'A5E';
    public const LABEL_TYPE_A5_E_EXTRA = 'A5E_EXTRA';
    public const LABEL_TYPE_A5_E_STAND = 'A5E_STAND';
    public const LABEL_TYPE_A6 = 'A6';
    public const LABEL_TYPE_A6IN_A4 = 'A6inA4';
    public const LABEL_TYPE_A4_ONE = 'A4ONE';
    public const LABEL_FORMAT_PDF = 'PDF';
    public const LABEL_FORMAT_ZPL = 'ZPL';
    public const DELIVERY_TIME_EARLY_MORNING = 'earlyMorning';
    public const DELIVERY_TIME_MORNING = 'morning';
    public const DELIVERY_TIME_AFTERNOON = 'afternoon';
    public const DELIVERY_TIME_EVENING = 'evening';
    public const PAYMENT_MODE_AT = 'UV_AT';
    public const PAYMENT_MODE_KP = 'UV_KP';
    public const PRINT_RECIPIENT_DATA_PRINTALL = 'PRINTALL';
    public const PRINT_RECIPIENT_DATA_PRINTPHONENUMBER = 'PRINTPHONENUMBER';
    public const PRINT_RECIPIENT_DATA_PRINTEMAIL = 'PRINTEMAIL';
    public const PRINT_RECIPIENT_DATA_PRINTNOTHING = 'PRINTNOTHING';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLabelTypeAllowableValues()
    {
        return [
            self::LABEL_TYPE_A4,
            self::LABEL_TYPE_A5,
            self::LABEL_TYPE_A5IN_A4,
            self::LABEL_TYPE_A5_E,
            self::LABEL_TYPE_A5_E_EXTRA,
            self::LABEL_TYPE_A5_E_STAND,
            self::LABEL_TYPE_A6,
            self::LABEL_TYPE_A6IN_A4,
            self::LABEL_TYPE_A4_ONE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLabelFormatAllowableValues()
    {
        return [
            self::LABEL_FORMAT_PDF,
            self::LABEL_FORMAT_ZPL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDeliveryTimeAllowableValues()
    {
        return [
            self::DELIVERY_TIME_EARLY_MORNING,
            self::DELIVERY_TIME_MORNING,
            self::DELIVERY_TIME_AFTERNOON,
            self::DELIVERY_TIME_EVENING,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentModeAllowableValues()
    {
        return [
            self::PAYMENT_MODE_AT,
            self::PAYMENT_MODE_KP,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPrintRecipientDataAllowableValues()
    {
        return [
            self::PRINT_RECIPIENT_DATA_PRINTALL,
            self::PRINT_RECIPIENT_DATA_PRINTPHONENUMBER,
            self::PRINT_RECIPIENT_DATA_PRINTEMAIL,
            self::PRINT_RECIPIENT_DATA_PRINTNOTHING,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('developer', $data ?? [], null);
        $this->setIfExists('sender', $data ?? [], null);
        $this->setIfExists('non_utf8_sender', $data ?? [], null);
        $this->setIfExists('shipment_date', $data ?? [], null);
        $this->setIfExists('order_id', $data ?? [], null);
        $this->setIfExists('webshop_id', $data ?? [], null);
        $this->setIfExists('label_type', $data ?? [], null);
        $this->setIfExists('label_format', $data ?? [], 'PDF');
        $this->setIfExists('tag', $data ?? [], null);
        $this->setIfExists('group_together', $data ?? [], null);
        $this->setIfExists('delivery_time', $data ?? [], null);
        $this->setIfExists('delivery_date', $data ?? [], null);
        $this->setIfExists('item', $data ?? [], null);
        $this->setIfExists('recipient', $data ?? [], null);
        $this->setIfExists('non_utf8_recipient', $data ?? [], null);
        $this->setIfExists('payment_mode', $data ?? [], null);
        $this->setIfExists('package_retention', $data ?? [], null);
        $this->setIfExists('print_recipient_data', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['developer'] === null) {
            $invalidProperties[] = "'developer' can't be null";
        }
        if ((mb_strlen($this->container['developer']) > 40)) {
            $invalidProperties[] = "invalid value for 'developer', the character length must be smaller than or equal to 40.";
        }

        if ((mb_strlen($this->container['developer']) < 1)) {
            $invalidProperties[] = "invalid value for 'developer', the character length must be bigger than or equal to 1.";
        }

        if ($this->container['sender'] === null) {
            $invalidProperties[] = "'sender' can't be null";
        }
        if (!is_null($this->container['order_id']) && (mb_strlen($this->container['order_id']) > 50)) {
            $invalidProperties[] = "invalid value for 'order_id', the character length must be smaller than or equal to 50.";
        }

        if ($this->container['webshop_id'] === null) {
            $invalidProperties[] = "'webshop_id' can't be null";
        }
        if ((mb_strlen($this->container['webshop_id']) > 100)) {
            $invalidProperties[] = "invalid value for 'webshop_id', the character length must be smaller than or equal to 100.";
        }

        if ((mb_strlen($this->container['webshop_id']) < 1)) {
            $invalidProperties[] = "invalid value for 'webshop_id', the character length must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getLabelTypeAllowableValues();
        if (!is_null($this->container['label_type']) && !in_array($this->container['label_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'label_type', must be one of '%s'",
                $this->container['label_type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLabelFormatAllowableValues();
        if (!is_null($this->container['label_format']) && !in_array($this->container['label_format'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'label_format', must be one of '%s'",
                $this->container['label_format'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['tag']) && (mb_strlen($this->container['tag']) > 50)) {
            $invalidProperties[] = "invalid value for 'tag', the character length must be smaller than or equal to 50.";
        }

        $allowedValues = $this->getDeliveryTimeAllowableValues();
        if (!is_null($this->container['delivery_time']) && !in_array($this->container['delivery_time'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'delivery_time', must be one of '%s'",
                $this->container['delivery_time'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['recipient'] === null) {
            $invalidProperties[] = "'recipient' can't be null";
        }
        $allowedValues = $this->getPaymentModeAllowableValues();
        if (!is_null($this->container['payment_mode']) && !in_array($this->container['payment_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_mode', must be one of '%s'",
                $this->container['payment_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPrintRecipientDataAllowableValues();
        if (!is_null($this->container['print_recipient_data']) && !in_array($this->container['print_recipient_data'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'print_recipient_data', must be one of '%s'",
                $this->container['print_recipient_data'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets developer
     *
     * @return string
     */
    public function getDeveloper()
    {
        return $this->container['developer'];
    }

    /**
     * Sets developer
     *
     * @param string $developer Az API-t hívó rendszer neve.   /   The name of the system calling API.
     *
     * @return self
     */
    public function setDeveloper($developer)
    {
        if (is_null($developer)) {
            throw new \InvalidArgumentException('non-nullable developer cannot be null');
        }
        if ((mb_strlen($developer) > 40)) {
            throw new \InvalidArgumentException('invalid length for $developer when calling ShipmentCreateRequest., must be smaller than or equal to 40.');
        }
        if ((mb_strlen($developer) < 1)) {
            throw new \InvalidArgumentException('invalid length for $developer when calling ShipmentCreateRequest., must be bigger than or equal to 1.');
        }

        $this->container['developer'] = $developer;

        return $this;
    }

    /**
     * Gets sender
     *
     * @return \WebnessStudio\MPL\Model\Sender
     */
    public function getSender()
    {
        return $this->container['sender'];
    }

    /**
     * Sets sender
     *
     * @param \WebnessStudio\MPL\Model\Sender $sender sender
     *
     * @return self
     */
    public function setSender($sender)
    {
        if (is_null($sender)) {
            throw new \InvalidArgumentException('non-nullable sender cannot be null');
        }
        $this->container['sender'] = $sender;

        return $this;
    }

    /**
     * Gets non_utf8_sender
     *
     * @return \WebnessStudio\MPL\Model\NonUTF8Sender|null
     */
    public function getNonUtf8Sender()
    {
        return $this->container['non_utf8_sender'];
    }

    /**
     * Sets non_utf8_sender
     *
     * @param \WebnessStudio\MPL\Model\NonUTF8Sender|null $non_utf8_sender non_utf8_sender
     *
     * @return self
     */
    public function setNonUtf8Sender($non_utf8_sender)
    {
        if (is_null($non_utf8_sender)) {
            throw new \InvalidArgumentException('non-nullable non_utf8_sender cannot be null');
        }
        $this->container['non_utf8_sender'] = $non_utf8_sender;

        return $this;
    }

    /**
     * Gets shipment_date
     *
     * @return \DateTime|null
     */
    public function getShipmentDate()
    {
        return $this->container['shipment_date'];
    }

    /**
     * Sets shipment_date
     *
     * @param \DateTime|null $shipment_date A tényleges (fizikai) postára adás tervezett ideje. Értéke legfeljebb 6 hónappal lehet később az aktuális napnál.   /   Planned time of actual (physical) posting. Its value can be up to 6 months later than the current day. format: date-time
     *
     * @return self
     */
    public function setShipmentDate($shipment_date)
    {
        if (is_null($shipment_date)) {
            array_push($this->openAPINullablesSetToNull, 'shipment_date');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('shipment_date', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['shipment_date'] = $shipment_date;

        return $this;
    }

    /**
     * Gets order_id
     *
     * @return string|null
     */
    public function getOrderId()
    {
        return $this->container['order_id'];
    }

    /**
     * Sets order_id
     *
     * @param string|null $order_id A webáruház által használt rendelésazonosító. A kérés/válasz ciklus után ezt az adatot az API-ban tároljuk, így a jegyzékzárás előtti lekérdezéseknél alapul szolgálhat az egyes szállítmányok beazonosításához. De jegyzékzárás után ez az adat már nem kíséri a csomagot az életútja során (pl. nyomkövetésnél).   /   The order identification number used by the online store. After the request/response cycle, this data is stored in the API, thus it may serve as a basis for the queries before closing the list to identify shipments. However, after closing the list, this data does not accompany the mail item in its life path (e.g. at tracking).
     *
     * @return self
     */
    public function setOrderId($order_id)
    {
        if (is_null($order_id)) {
            array_push($this->openAPINullablesSetToNull, 'order_id');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('order_id', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($order_id) && (mb_strlen($order_id) > 50)) {
            throw new \InvalidArgumentException('invalid length for $order_id when calling ShipmentCreateRequest., must be smaller than or equal to 50.');
        }

        $this->container['order_id'] = $order_id;

        return $this;
    }

    /**
     * Gets webshop_id
     *
     * @return string
     */
    public function getWebshopId()
    {
        return $this->container['webshop_id'];
    }

    /**
     * Sets webshop_id
     *
     * @param string $webshop_id Az adott szállítmány azonosítója a kérés/válasz párban. A kérés/válasz ciklus után ezt az adatot már nem tároljuk, így a további API-hívásoknál már nem szolgál alapul, és jegyzékzárás után sem kíséri a csomagot az életútja során (pl. nyomkövetésnél). Mivel egy kérésben több szállítmány is beküldhető, ezért a szállítmányok mellé megadott azonosítóval lehet \"párosítani\" a kapott választ. Értékének ezért egy híváson belül kell egyedninek lennie, a legegyszerűbb egy 0-től kezdődő sorszám, de akár használható a webshop által kiosztott megrendelésazonosító is, ha megfelel a formai követelményeknek   /   The ID of the given shipment in the request/response pair. After the request/response cycle, we do not store this data anymore, thus it is no longer used as a basis for further API queries, and it does not accompany the mail items in their life path after the closing of the list (e.g. at tracking). Because multiple consignments can be submitted in one request, the response can be ‘paired’ with the ID provided for the consignments. Its value must therefore be unique within a call, the simplest being a serial number starting from 0, but you can even use the order ID assigned by the webshop if it meets the formal requirements.
     *
     * @return self
     */
    public function setWebshopId($webshop_id)
    {
        if (is_null($webshop_id)) {
            throw new \InvalidArgumentException('non-nullable webshop_id cannot be null');
        }
        if ((mb_strlen($webshop_id) > 100)) {
            throw new \InvalidArgumentException('invalid length for $webshop_id when calling ShipmentCreateRequest., must be smaller than or equal to 100.');
        }
        if ((mb_strlen($webshop_id) < 1)) {
            throw new \InvalidArgumentException('invalid length for $webshop_id when calling ShipmentCreateRequest., must be bigger than or equal to 1.');
        }

        $this->container['webshop_id'] = $webshop_id;

        return $this;
    }

    /**
     * Gets label_type
     *
     * @return string|null
     */
    public function getLabelType()
    {
        return $this->container['label_type'];
    }

    /**
     * Sets label_type
     *
     * @param string|null $label_type A címirat elrendezése (mérete, tájolása). Részletes magyarázat a Dokumentáció menüben olvasható. Amennyiben nem érkezik ilyen paraméter, úgy a válasz nem tartalmaz majd címiratot. A címirat később is lekérhető, GET hívással.   /   Layout of postal address label.Detailed explanations can be found in the Documentation menu.If this parameter is not specified, then no manifest will be included in the response. The label can be generated later by a GET request.
     *
     * @return self
     */
    public function setLabelType($label_type)
    {
        if (is_null($label_type)) {
            array_push($this->openAPINullablesSetToNull, 'label_type');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('label_type', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getLabelTypeAllowableValues();
        if (!is_null($label_type) && !in_array($label_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'label_type', must be one of '%s'",
                    $label_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['label_type'] = $label_type;

        return $this;
    }

    /**
     * Gets label_format
     *
     * @return string|null
     */
    public function getLabelFormat()
    {
        return $this->container['label_format'];
    }

    /**
     * Sets label_format
     *
     * @param string|null $label_format A címirat fájl formátuma. Több címiratot tartalmazó PDF érdekében a szállítmányok beküldését követőn egy külön GET hívással kell címkét kérni.   /   File format of the label. To create a PDF containing multiple labels, an additional GET request need to be sent after the shipments have been submitted.
     *
     * @return self
     */
    public function setLabelFormat($label_format)
    {
        if (is_null($label_format)) {
            array_push($this->openAPINullablesSetToNull, 'label_format');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('label_format', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getLabelFormatAllowableValues();
        if (!is_null($label_format) && !in_array($label_format, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'label_format', must be one of '%s'",
                    $label_format,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['label_format'] = $label_format;

        return $this;
    }

    /**
     * Gets tag
     *
     * @return string|null
     */
    public function getTag()
    {
        return $this->container['tag'];
    }

    /**
     * Sets tag
     *
     * @param string|null $tag A szállítmányok opcionálisan megjelölhetők. A kérés/válasz ciklus után ezt a jelölőt az API-ban tároljuk, így a jegyzékzárás előtti lekérdezéseknél vagy a címiratok csoportos nyomtatásánál alapul szolgálhat a szállítmányok egy csoportjára szűrésére. De jegyzékzárás után ez az adat már nem kíséri a csomagot az életútja során (pl. nyomkövetésnél).   /   Shipments can be optionally marked. After the request/response cycle, this marking is stored in the API, thus it may serve as a basis for the queries before closing the list or for the group printing of address labels to filter out a particular group of shipments. However, after closing the list, these data do not accompany the mail item in its life path (e.g. at tracking).
     *
     * @return self
     */
    public function setTag($tag)
    {
        if (is_null($tag)) {
            array_push($this->openAPINullablesSetToNull, 'tag');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('tag', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        if (!is_null($tag) && (mb_strlen($tag) > 50)) {
            throw new \InvalidArgumentException('invalid length for $tag when calling ShipmentCreateRequest., must be smaller than or equal to 50.');
        }

        $this->container['tag'] = $tag;

        return $this;
    }

    /**
     * Gets group_together
     *
     * @return bool|null
     */
    public function getGroupTogether()
    {
        return $this->container['group_together'];
    }

    /**
     * Sets group_together
     *
     * @param bool|null $group_together ►DOM◄ A beküldött szállítmány csomagjai (item) együtt kézbesítendők-e? Díjmentes szolgáltatás.   /   May the mail items of the shipment sent in be delivered together? Free of charge service.
     *
     * @return self
     */
    public function setGroupTogether($group_together)
    {
        if (is_null($group_together)) {
            array_push($this->openAPINullablesSetToNull, 'group_together');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('group_together', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['group_together'] = $group_together;

        return $this;
    }

    /**
     * Gets delivery_time
     *
     * @return string|null
     */
    public function getDeliveryTime()
    {
        return $this->container['delivery_time'];
    }

    /**
     * Sets delivery_time
     *
     * @param string|null $delivery_time A kívánt kézbesítési idő. Csak az időablak (K_IDA) többletszolgáltatás esetén szükséges megadni.   /   The required delivery time. It must be provided only in case of the additional service of time-window delivery (K_IDA).
     *
     * @return self
     */
    public function setDeliveryTime($delivery_time)
    {
        if (is_null($delivery_time)) {
            array_push($this->openAPINullablesSetToNull, 'delivery_time');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('delivery_time', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getDeliveryTimeAllowableValues();
        if (!is_null($delivery_time) && !in_array($delivery_time, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'delivery_time', must be one of '%s'",
                    $delivery_time,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['delivery_time'] = $delivery_time;

        return $this;
    }

    /**
     * Gets delivery_date
     *
     * @return \DateTime|null
     */
    public function getDeliveryDate()
    {
        return $this->container['delivery_date'];
    }

    /**
     * Sets delivery_date
     *
     * @param \DateTime|null $delivery_date A kívánt kézbesítési nap. Csak a fix napi kézbesítés (K_FNK) többletszolgáltatás esetén szükséges megadni.   /   The required delivery date. It must be provided only in case of the additional service of fixed day delivery (K_FNK).
     *
     * @return self
     */
    public function setDeliveryDate($delivery_date)
    {
        if (is_null($delivery_date)) {
            array_push($this->openAPINullablesSetToNull, 'delivery_date');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('delivery_date', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['delivery_date'] = $delivery_date;

        return $this;
    }

    /**
     * Gets item
     *
     * @return \WebnessStudio\MPL\Model\Item[]|null
     */
    public function getItem()
    {
        return $this->container['item'];
    }

    /**
     * Sets item
     *
     * @param \WebnessStudio\MPL\Model\Item[]|null $item A tételek (csomagok) felsorolása.   /   List of items (parcels).
     *
     * @return self
     */
    public function setItem($item)
    {
        if (is_null($item)) {
            array_push($this->openAPINullablesSetToNull, 'item');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('item', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['item'] = $item;

        return $this;
    }

    /**
     * Gets recipient
     *
     * @return \WebnessStudio\MPL\Model\Recipient
     */
    public function getRecipient()
    {
        return $this->container['recipient'];
    }

    /**
     * Sets recipient
     *
     * @param \WebnessStudio\MPL\Model\Recipient $recipient recipient
     *
     * @return self
     */
    public function setRecipient($recipient)
    {
        if (is_null($recipient)) {
            throw new \InvalidArgumentException('non-nullable recipient cannot be null');
        }
        $this->container['recipient'] = $recipient;

        return $this;
    }

    /**
     * Gets non_utf8_recipient
     *
     * @return \WebnessStudio\MPL\Model\NonUTF8Recipient|null
     */
    public function getNonUtf8Recipient()
    {
        return $this->container['non_utf8_recipient'];
    }

    /**
     * Sets non_utf8_recipient
     *
     * @param \WebnessStudio\MPL\Model\NonUTF8Recipient|null $non_utf8_recipient non_utf8_recipient
     *
     * @return self
     */
    public function setNonUtf8Recipient($non_utf8_recipient)
    {
        if (is_null($non_utf8_recipient)) {
            throw new \InvalidArgumentException('non-nullable non_utf8_recipient cannot be null');
        }
        $this->container['non_utf8_recipient'] = $non_utf8_recipient;

        return $this;
    }

    /**
     * Gets payment_mode
     *
     * @return string|null
     */
    public function getPaymentMode()
    {
        return $this->container['payment_mode'];
    }

    /**
     * Sets payment_mode
     *
     * @param string|null $payment_mode Azt adja meg, hogy az MPL hogyan fizesse ki az utánvételes csomagok után beszedett díjat a megrendelő számára.   /   Specifies how MPL should pay the customer the fee collected for cash on delivery parcels.
     *
     * @return self
     */
    public function setPaymentMode($payment_mode)
    {
        if (is_null($payment_mode)) {
            array_push($this->openAPINullablesSetToNull, 'payment_mode');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('payment_mode', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getPaymentModeAllowableValues();
        if (!is_null($payment_mode) && !in_array($payment_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_mode', must be one of '%s'",
                    $payment_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_mode'] = $payment_mode;

        return $this;
    }

    /**
     * Gets package_retention
     *
     * @return int|null
     */
    public function getPackageRetention()
    {
        return $this->container['package_retention'];
    }

    /**
     * Sets package_retention
     *
     * @param int|null $package_retention A csomag őrzési ideje munkanapban: 0, 5 vagy 10.   /   Retention period of the parcel in business days: 0, 5 or 10.
     *
     * @return self
     */
    public function setPackageRetention($package_retention)
    {
        if (is_null($package_retention)) {
            array_push($this->openAPINullablesSetToNull, 'package_retention');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('package_retention', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['package_retention'] = $package_retention;

        return $this;
    }

    /**
     * Gets print_recipient_data
     *
     * @return string|null
     */
    public function getPrintRecipientData()
    {
        return $this->container['print_recipient_data'];
    }

    /**
     * Sets print_recipient_data
     *
     * @param string|null $print_recipient_data 
     *
     * @return self
     */
    public function setPrintRecipientData($print_recipient_data)
    {
        if (is_null($print_recipient_data)) {
            array_push($this->openAPINullablesSetToNull, 'print_recipient_data');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('print_recipient_data', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $allowedValues = $this->getPrintRecipientDataAllowableValues();
        if (!is_null($print_recipient_data) && !in_array($print_recipient_data, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'print_recipient_data', must be one of '%s'",
                    $print_recipient_data,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['print_recipient_data'] = $print_recipient_data;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


